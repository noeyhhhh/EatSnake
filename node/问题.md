## 浏览器原理

### 简述浏览器渲染过程

1. **_输入 URL，浏览器根据 DNS 服务器得到域名的 IP 地址_**
2. **_向服务器请求，服务器返回请求，客户端得到返回的内容_**
3. **_自上而下生成 DOM 树_**
4. **_渲染 CSS 树，生成 cssom_**
5. **_渲染 laypout，计算节点大小，位置_**
6. **_根据以上结果进行页面渲染_**
7. **_渲染过程中遇到 scropt 就停止渲染，先执行 JS 代码_**

### 什么是回流/重排

**_回流：当 render tree 中的元素的宽高，布局，显示隐藏等元素内部文字结构发生改变时，就会影响其父元素甚至祖先元素发生改变，因此导致周围元素或整个页面发生改变，需要重新渲染，页面重构就是回流_**

**_重绘：元素的结构没有发生改变，只是样式外观发生改变，称为重绘_**

**_回流一定会重绘，重绘不一定回流_**

**_回流重绘会造成浏览器耗时，卡顿，最好不要频繁重复改变 dom。_**

## HTML

### Html5 新特性

**_新增语义化标签:header,footer,section,nav,article_**

**_新增音视频:audio,video._**

**_新增表单控件:search,url,date,email,calendar_**

**_新增绘图:(Canvas)API_**

**_新增地理:(Geoloacation)API_**

**_新技术:websocket,webwork._**

###

## CSS

### CSS 常见布局方式

1. **float 布局**

2. **流体布局**

3. **<u>圣杯布局!</u>important**

   **_左右两边两个 div 宽度固定,中间的宽度自适应的三栏布局._**

   **_目的是中间的盒子放在文档流最前面优先渲染._**

   **_原理:left,center,right 都向左浮动,center100%宽度实现自适应.left 向左偏移 center 的宽度上一层,再通过定位到最左边.right 通过 margin-right 来到上一层_**

   ```html
   <style>
       * {
         margin: 0;
         padding: 0
       }
       body{
         width:100vw;
         height:100vh;
       }
       .container{
         padding: 0 100px;
         background-color: black;
       }
       .center{
         width: 100%;
         height: 500px;
         background-color: blue;
       }
       .left{
         width: 100px;
         height: 500px;
         background-color: red;
         margin-left: -100%;
         position: relative;
         right: 100px;
       }
       .right{
         width: 100px;
         height: 500px;
         background-color: yellow;
         margin-right: -100px;
       }
       .container > div{
         float: left;
       }
     </style>
   </head>
   <body>
   <div class="container">
     <div class="center"></div>
     <div class="left"></div>
     <div class="right"></div>
   </div>
   ```

4. **<u>双飞翼布局!</u>**

   **_与圣杯布局思路大致相同,实现两边宽,中间自适应的三栏布局._**

   **_不同之处在于圣杯布局利用了父盒子的 padding 值为左右两栏预留位置,而双飞翼布局是给中间盒子加了一个盒子,利用 center 的两边 margin 为两栏预留位置_**

   ```html
     <style>
       * {
         margin: 0;
         padding: 0
       }
       body{
         width:100vw;
         height:100vh;
       }
       .con > div{
         float: left;
       }
       .wrap{
         height: 500px;
         width: 100%;
         background-color: black;
       }
       .left{
         width: 100px;
         height: 500px;
         background-color: red;
         margin-left: -100%;
       }
       .right{
         width: 100px;
         height: 500px;
         background-color: yellow;
         margin-left: -100px;
       }
       .center{
         margin: 0 100px;
       }
     </style>
   </head>
   <body>
   <div class="con">
     <div class="wrap">
       <div class="center">中</div>
     </div>
     <div class="left">左</div>
     <div class="right">右</div>
   </div>
   </body>
   ```

5. **flex 布局**

### 简述盒子模型

**_盒子模型分为 w3c 标准盒模型和怪异盒模型(IE 盒)_**

**_怪异盒模型的长宽包括了 content+padding+border_**

**_标准盒模型的长宽只有 content_**

**_border-size:content-size 标准盒模型_**

**_border-size:border-size 怪异盒模型_**

**_border-size:padding-size 长宽为 content+padding_**

### 什么是 BFC,如何触发 BFC,BFC 的特征,应用

**_概念:_**

**_直译"块级格式化上下文",它是一个独立的渲染区域_**

**_特征:_**

**_通俗一点来讲,可以把 BFC 理解为一个封闭的大箱子,箱子内部的元素无论如何都不会影响到外部元素_**

1. **_内部的 box 会在垂直方向,从顶部开始一个接一个的放置_**
2. **_box 垂直方向的距离由 margin 决定,属于同一个 BFC 的两个相邻 BOX 的 margin 会发生叠加._**
3. **_每个元素的 marginbox 左边,与包含块 border box 的左边相接触,即使在浮动元素中也是这样_**
4. **_BFC 区域不会和 float box 叠加,利用此特性可以实现两列布局,左边固定宽度,右边自适应_**
5. **_具有 BFC 特性的元素可以看作是隔离了的独立容器,容器里面的元素不会在布局上影响外面的元素_**
6. **_计算 BFC 的高度时,浮动元素也会参与计算_**

**_如何产生 BFC_**

1. **_添加浮动_**
2. **_定位,position:absolute,fixed_**
3. **_display 属性:inline-block,flex,inline-flex,tabe-cell.._**
4. **_overflow 属性,hidden,auto,scroll_**

**_BFC 应用_**

**_自适应两栏布局,margin 重合,清除浮动,margin 的紧急拖拽_**

**_解决高度塌陷问题,给父元素添加 overflow:hidden_**

**_解决兄弟元素之间外边距塌陷问题,给其中一个兄弟盒子外层再添加一个盒子_**

### 居中的方式

**_垂直居中：_**

1. **_lineheight = height_**
2. **_绝对定位 top50%，left50%，margin-left/top: -自身宽度 50%_**
3. **_flex 布局_**
4. **_margin:auto 0_**

**_水平居中_**

1. **_flex 布局_**
2. **_margin:0 auto_**
3. **_text-align center_**

### rem、em、vh、px

**_rem：相对单位，给 Html 元素设置一个字体大小，rem 就是相对于 HTML 字体的大小_**

**_em：相对单位，子元素相对于父元素的大小_**

**_vw/vh：视窗的宽高_**

**_px：精准像素单位_**

### 实现元素隐藏的方法

**_display:none_**

**_visibilty:hidden_**

**_opacity:0_**

**_heigth weight : 0_**

**_clip-path_**

### 什么是响应式设计？响应式基本原理是什么？

**_页面根据用户行为以及设备环境进行相应的调整，即只需要一道代码使页面适应不同的屏幕_**

1. **_百分比布局_**
2. **_rem 布局_**
3. **_媒体查询_**
4. **_flex 布局_**
5. **_vw/vh_**

### CSS 选择器及其优先级

**_id 选择器，类选择器，标签选择器，后代选择器，子选择器，相邻同胞选择器，群组选择器_**

**_伪类选择器：:link :visited :active :hover :focus :first-child_**

**_伪元素选择器： :first-letter :first-line :before :after_**

**_属性选择器： :[attrute] :[attribute=value] :[attribute~=value] :[attribute|=value]_**

**_css3 新增选择器_**

**_层级选择器_**

**_伪类选择器： :first-of-type :last-of-type :only-of-type :onlu-child :nth-child(n) :nth-last-of-type(n)......._**

**_优先级：_**

**_内联 1000>ID 选择器 0100>类选择器 0010>标签选择器 0001_**

**_伪类 0010_**

### 清楚浮动的方法

**_clear 属性_**

**_overflow 属性_**

**_给浮动元素的容器添加浮动_**

### 常见的行内元素/块级元素

**_块级元素 div,p,h1,ol,ul,table_**

**_行内元素 span,a,img,input,strong_**

### SOE 需要考虑什么

- **_语义化 HTML 标签_**
- **_合理的 title，description，keywords_**
- **_重要的 html 代码放前面_**
- **_少用 iframe_**
- **_图片加上 alt_**

## JavaScript

### ES6 新增了

**_includes() find() findindex() set 数据结构 let const 解构赋值_**

### set 和 map 的区别

1. **_map 是键值对，set 是值得集合，键和值可以是任何的值_**
2. **_map 可以通过 get 方法获取值，而 set 不能因为它只有值，set 只能用 has 来判断，返回一个布尔值_**
3. **_set 的值是唯一的可以做数组去重，map 由于没有格式限制，可以做数据存储_**

### 简述 for..of 和 for..in 的区别

**_for-in 一般遍历普通对象,for-of 一般遍历普通数组_**

**_for-in 遍历的是索引和自定义属性,for-of 遍历的是值_**

**_JS 中的可枚举属性和不可枚举属性_**

**_原装属性是不可枚举的,Object,Array,Number_**

### 什么是 promise 及其作用

**_是 ES6 中的一个内置对象，实际是一个构造函数_**

**_promise 构建出来的实力存在以下方法：_**

- **_then 是实力状态发生改变时的回调函数，第一个函数时 resolved 状态的回调函数，第二个参数是 rejected 状态的回调函数_**
- **_catch 用于指定发生错误时的回调函数_**
- **_finally 用于指定不管 promise 对象最后状态如何，都会执行的操作_**

**_Promise 构造函数存在以下方法_**

- **_all()用于将多个 Promise 实例，包装成一个新的 Promise 实例_**
- **_race()同样是将多个 Promise 实例，包装成一个新的 Promise 实例_**

**_特点：_**

**_三种状态，pending、resolved、rejected。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都不能改变这个状态_**

**_两个状态的转变，从 pending-resolved，pending-rejected。只有这两种形态的转变_**

**_Promised 构造函数的原型对象上，有 then 和 catch 方法，then 接受 resolved 传来的数据，catch 接受 resolved 传来的数据_**

**_作用_**

**_解决异步问题_**

**_解决多层回调问题_**

### var/let/const 区别

- **_var 声明的变量存在变量提升，即变量可以在声明之前调用，let 和 const 不存在变量提升，它们的声明一定要在调用之前_**
- **_var 不存在暂时性死区，let 和 const 存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量_**
- **_var 声明的是全局变量，let 和 const 声明的是局部变量_**
- **_var 允许重复声明，let 和 const 在同一个作用域内不允许重复声明变量_**
- **_const 声明的变量为只读_**

### == 和 ===

**_==会自动做类型转换，在进行值得比较，===不会做类型转换_**

### 数组常用方法

#### **_增_**

**_push 接受任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度_**

**_unshift 开头添加任意数量的参数_**

**_concat 首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组_**

#### **_删_**

**_pop 删除数组最后一项，返回被删除的项_**

**_shift 删除数组第一项_**

**_splice 传入两个参数，分别是开始位置和删除元素的数量，返回包含删除元素的数组_**

**_slice 创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组_**

#### **_改_**

**_splice 第三个参数为插入的元素_**

#### **_查_**

**_indexOf 返回要查找的元素在数组中的位置，没有找到返回-1_**

**_includes 返回要查找的元素在数组中的位置，找到返回 true，否则 false_**

**_find()返回第一个匹配的元素_**

#### **_排序_**

**_reverse 将数组元素反转_**

**_sort 第一个参数首元素地址，第二参数尾元素地址，第三个比较函数。_**

**_join 接受一个参数，用于分隔字符串，返回字符串_**

#### **_迭代_**

**_some 对数组每一项都运行传入的函数，有一项返回 true，则返回 true_**

**_every 对数组每一项都运行传入的函数，每一项返回 true，则返回 true_**

**_forEach 对数组每一项都运行传入的函数，没有返回值_**

**_filter 对每一项都运行传入的函数，函数返回 true 的项会组成数组并返回_**

**_map 对数组每一项都运行传入的函数，函数返回的结果构成新的数组_**

#### **_去重的几种方法_**

1. **_利用 set 去重，let new = new set(重复数组)_**

2. **_利用 indexOf_**

3. **_双重 for 循环_**

### 简述 bind，call，apply 及其异别

#### **_apply 方法_**

**_apply 方法接受两个参数，第一个参数是 this 的指向，第二个参数是函数默认接受的参数，以数组的形式传入，且当第一个参数为 null，undefined 的时候，默认指向 windows，使用 apply 方法改变 this 指向后原函数会立即执行，此方法只能临时改变 this 指向一次_**

#### **_call 方法_**

**_call 第一个参数也是 this 的指向，后面传入的是一个参数列表（注意和 apply 传参的区别）。当一个参数为 null 或 undefined 的时候，表示指向 window（在浏览器中）_**

#### **_bind 方法_**

**_第一个参数是 this 的指向，后面传入的也是一个参数列表（但是这个参数列表可以分多次传入），但是 bind 改变 this 指向后不会立即执行，而是返回一个永久改变 this 指向的函数_**

#### **_区别：_**

- **_三者都可以改变函数 this 对象指向_**
- **_三者的第一个参数都是 this 要指向的对象，如果没有这个参数或者参数为 nul、undefined，则默认指向全局 window_**
- **_三者都可以传参，但是 apply 是数组，call 是参数列表，bind 可以分多次传入_**
- **_bind 是返回绑定 this 之后的函数，便于稍后调用，apply,call 则是立即执行_**

### 本地存储的方式有哪些？区别及应用场景

四种方式：cookie sessionStorage locakStorage indexedDB

### 简述 async 和 await

async 用于声明一个 function 是异步的，await 用于等待一个异步方法执行完毕

async 返回的是一个 promise 对象

### 讲解深拷贝和浅拷贝

## Vue

### vuex、localStorage、sessionStorage 之间的区别

1. **_vuex 存储在内存中,localstorage 以文件形式存储在本地,sessionstorage 针对一个 session 进行数据存储._**
2. **_页面刷新后 vuex 存储的数据会被清除,localstorage 是永久存储,sessionstorage 临时存储,窗口关闭后数据会被清除_**
3. **_vuex 用于组件之间的传值,localstorage 和 sessionstorage 则主要用于不同页面之间的传值(其他页面更新数据后,当前页面要刷新才能相应更新),vuex 则是响应式的._**

### 为什么 vue 组件中的 data 必须是函数?

**_Vue 根实例的 data 可以是对象也可以使函数,组件是复用的 Vue 实例,把公共的模块抽离出来,达到复用和直接使用的效果.如果组件中 data 是一个对象的话,对象是引用类型,会在堆空间中开辟一片区域,使得所有组件会公共是一个 data 开辟的区域,一个组件修改所有 data 数据都会改变.所以组件中的 data 得是一个函数,利用 return 返回一个对象,每次使用组件就会返回一个全新的 data.组件与组件之间的 data 互相不干涉,类似于 style 的 scoped_**

## HTTP

### POST 和 GET 区别

**_相同的是都是 HTTP 请求_** **_区别:_** **_get 请求在浏览器刷新或者会退的时候是无害的.但是 POST 请求会重新提交_** **_GET 数据类型 urlencode,POSTshi URLENCODE,form-data_** **_get 将 data 和 headers 一起发给后端,但是 post 会先发 header 等到后端返回 100 以后,再在 body 中发 data 给后端_**

###
