## 浏览器原理

### 简述浏览器渲染过程

1. ***输入URL，浏览器根据DNS服务器得到域名的IP地址***
2. ***向服务器请求，服务器返回请求，客户端得到返回的内容***
3. ***自上而下生成DOM树***
4. ***渲染CSS树，生成cssom***
5. ***渲染laypout，计算节点大小，位置***
6. ***根据以上结果进行页面渲染***
7. ***渲染过程中遇到scropt就停止渲染，先执行JS代码***



### 什么是回流/重排

***回流：当render tree中的元素的宽高，布局，显示隐藏等元素内部文字结构发生改变时，就会影响其父元素甚至祖先元素发生改变，因此导致周围元素或整个页面发生改变，需要重新渲染，页面重构就是回流***

***重绘：元素的结构没有发生改变，只是样式外观发生改变，称为重绘***

***回流一定会重绘，重绘不一定回流***

***回流重绘会造成浏览器耗时，卡顿，最好不要频繁重复改变dom。***











## HTML

### Html5新特性

***新增语义化标签:header,footer,section,nav,article***

***新增音视频:audio,video.***

***新增表单控件:search,url,date,email,calendar***

***新增绘图:(Canvas)API***

***新增地理:(Geoloacation)API***

***新技术:websocket,webwork.***



### 



## CSS

### CSS常见布局方式

1. **float布局**

2. **流体布局**

3. **<u>圣杯布局!</u>important**

   ***左右两边两个div宽度固定,中间的宽度自适应的三栏布局.***

   ***目的是中间的盒子放在文档流最前面优先渲染.***

   ***原理:left,center,right都向左浮动,center100%宽度实现自适应.left向左偏移center的宽度上一层,再通过定位到最左边.right通过margin-right来到上一层***

   ```html
   <style>
       * {
         margin: 0;
         padding: 0
       }
       body{
         width:100vw;
         height:100vh;
       }
       .container{
         padding: 0 100px;
         background-color: black;
       }
       .center{
         width: 100%;
         height: 500px;
         background-color: blue;
       }
       .left{
         width: 100px;
         height: 500px;
         background-color: red;
         margin-left: -100%;
         position: relative;
         right: 100px;
       }
       .right{
         width: 100px;
         height: 500px;
         background-color: yellow;
         margin-right: -100px;
       }
       .container > div{
         float: left;
       }
     </style>
   </head>
   <body>
   <div class="container">
     <div class="center"></div>
     <div class="left"></div>
     <div class="right"></div>
   </div>
   ```

   

4. **<u>双飞翼布局!</u>**

   ***与圣杯布局思路大致相同,实现两边宽,中间自适应的三栏布局.***

   ***不同之处在于圣杯布局利用了父盒子的padding值为左右两栏预留位置,而双飞翼布局是给中间盒子加了一个盒子,利用center的两边margin为两栏预留位置***

   ```html
     <style>
       * {
         margin: 0;
         padding: 0
       }
       body{
         width:100vw;
         height:100vh;
       }
       .con > div{
         float: left;
       }
       .wrap{
         height: 500px;
         width: 100%;
         background-color: black;
       }
       .left{
         width: 100px;
         height: 500px;
         background-color: red;
         margin-left: -100%;
       }
       .right{
         width: 100px;
         height: 500px;
         background-color: yellow;
         margin-left: -100px;
       }
       .center{
         margin: 0 100px;
       }
     </style>
   </head>
   <body>
   <div class="con">
     <div class="wrap">
       <div class="center">中</div>
     </div>
     <div class="left">左</div>
     <div class="right">右</div>
   </div>
   </body>
   ```

5. **flex布局**



### 简述盒子模型

***盒子模型分为w3c标准盒模型和怪异盒模型(IE盒)***

***怪异盒模型的长宽包括了content+padding+border***

***标准盒模型的长宽只有content***

***border-size:content-size 标准盒模型***

***border-size:border-size 怪异盒模型***

***border-size:padding-size长宽为content+padding***



### 什么是BFC,如何触发BFC,BFC的特征,应用

***概念:***

***直译"块级格式化上下文",它是一个独立的渲染区域***

***特征:***

***通俗一点来讲,可以把BFC理解为一个封闭的大箱子,箱子内部的元素无论如何都不会影响到外部元素***

1. ***内部的box会在垂直方向,从顶部开始一个接一个的放置***
2. ***box垂直方向的距离由margin决定,属于同一个BFC的两个相邻BOX的margin会发生叠加.***
3. ***每个元素的marginbox左边,与包含块border box的左边相接触,即使在浮动元素中也是这样***
4. ***BFC区域不会和float box叠加,利用此特性可以实现两列布局,左边固定宽度,右边自适应***
5. ***具有BFC特性的元素可以看作是隔离了的独立容器,容器里面的元素不会在布局上影响外面的元素***
6. ***计算BFC的高度时,浮动元素也会参与计算***

***如何产生BFC***

1. ***添加浮动***
2. ***定位,position:absolute,fixed***
3. ***display属性:inline-block,flex,inline-flex,tabe-cell..***
4. ***overflow属性,hidden,auto,scroll***

***BFC应用***

***自适应两栏布局,margin重合,清除浮动,margin的紧急拖拽***

***解决高度塌陷问题,给父元素添加overflow:hidden***

***解决兄弟元素之间外边距塌陷问题,给其中一个兄弟盒子外层再添加一个盒子***



### 居中的方式

***垂直居中：***

1. ***lineheight = height***
2. ***绝对定位top50%，left50%，margin-left/top:   -自身宽度50%***
3. ***flex布局***
4. ***margin:auto 0***

***水平居中***

1. ***flex布局***
2. ***margin:0 auto***
3. ***text-align center***



### rem、em、vh、px

***rem：相对单位，给Html元素设置一个字体大小，rem就是相对于HTML字体的大小***

***em：相对单位，子元素相对于父元素的大小***

***vw/vh：视窗的宽高***

***px：精准像素单位***



### 实现元素隐藏的方法

***display:none***

***visibilty:hidden***

***opacity:0***

***heigth weight : 0***

***clip-path***



### 什么是响应式设计？响应式基本原理是什么？

***页面根据用户行为以及设备环境进行相应的调整，即只需要一道代码使页面适应不同的屏幕***

1. ***百分比布局***
2. ***rem布局***
3. ***媒体查询***
4. ***flex布局***
5. ***vw/vh***



### CSS选择器及其优先级

***id选择器，类选择器，标签选择器，后代选择器，子选择器，相邻同胞选择器，群组选择器***

***伪类选择器：:link	:visited	:active	:hover	:focus	:first-child***

***伪元素选择器：	:first-letter	:first-line	:before	:after***

***属性选择器：	:[attrute]	:[attribute=value]	:[attribute~=value]	:[attribute|=value]***

***css3新增选择器***

***层级选择器***

***伪类选择器：	:first-of-type	:last-of-type	:only-of-type	:onlu-child	:nth-child(n)	:nth-last-of-type(n).......***

***优先级：***

***内联1000>ID选择器0100>类选择器0010>标签选择器0001***

***伪类0010***



### 清楚浮动的方法

***clear属性***

***overflow属性***

***给浮动元素的容器添加浮动***



### 常见的行内元素/块级元素

***块级元素div,p,h1,ol,ul,table***

***行内元素span,a,img,input,strong***



### SOE需要考虑什么

- ***语义化HTML标签***
- ***合理的title，description，keywords***
- ***重要的html代码放前面***
- ***少用iframe***
- ***图片加上alt***





















## JavaScript

### ES6新增了

***includes()	find()	findindex()	 set数据结构 	let 	const	解构赋值***



### set和map的区别

1. ***map是键值对，set是值得集合，键和值可以是任何的值***
2. ***map可以通过get方法获取值，而set不能因为它只有值，set只能用has来判断，返回一个布尔值***
3. ***set的值是唯一的可以做数组去重，map由于没有格式限制，可以做数据存储***



### 简述for..of和for..in的区别

***for-in一般遍历普通对象,for-of一般遍历普通数组***

***for-in遍历的是索引和自定义属性,for-of遍历的是值***

***JS中的可枚举属性和不可枚举属性***

***原装属性是不可枚举的,Object,Array,Number***



### 什么是promise及其作用

***是ES6中的一个内置对象，实际是一个构造函数***

***promise构建出来的实力存在以下方法：***

- ***then是实力状态发生改变时的回调函数，第一个函数时resolved状态的回调函数，第二个参数是rejected状态的回调函数***
- ***catch用于指定发生错误时的回调函数***
- ***finally用于指定不管promise对象最后状态如何，都会执行的操作***

***Promise构造函数存在以下方法***

- ***all()用于将多个Promise实例，包装成一个新的Promise实例***
- ***race()同样是将多个Promise实例，包装成一个新的Promise实例***

***特点：***

***三种状态，pending、resolved、rejected。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都不能改变这个状态***

***两个状态的转变，从pending-resolved，pending-rejected。只有这两种形态的转变***

***Promised构造函数的原型对象上，有then和catch方法，then接受resolved传来的数据，catch接受resolved传来的数据***

***作用***

***解决异步问题***

***解决多层回调问题***



### var/let/const区别

- ***var声明的变量存在变量提升，即变量可以在声明之前调用，let和const不存在变量提升，它们的声明一定要在调用之前***
- ***var不存在暂时性死区，let和const存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量***
- ***var声明的是全局变量，let和const声明的是局部变量***
- ***var允许重复声明，let和const在同一个作用域内不允许重复声明变量***
- ***const声明的变量为只读***



### == 和 ===

***==会自动做类型转换，在进行值得比较，===不会做类型转换***



### 数组常用方法

#### ***增***

***push接受任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度***

***unshift开头添加任意数量的参数***

***concat首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组***

#### ***删***

***pop删除数组最后一项，返回被删除的项***

***shift删除数组第一项***

***splice传入两个参数，分别是开始位置和删除元素的数量，返回包含删除元素的数组***

***slice创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组***

#### ***改***

***splice第三个参数为插入的元素***

#### ***查***

***indexOf返回要查找的元素在数组中的位置，没有找到返回-1***

***includes返回要查找的元素在数组中的位置，找到返回true，否则false***

***find()返回第一个匹配的元素***

#### ***排序***

***reverse将数组元素反转***

***sort第一个参数首元素地址，第二参数尾元素地址，第三个比较函数。***

***join接受一个参数，用于分隔字符串，返回字符串***

#### ***迭代***

***some对数组每一项都运行传入的函数，有一项返回true，则返回true***

***every对数组每一项都运行传入的函数，每一项返回true，则返回true***

***forEach对数组每一项都运行传入的函数，没有返回值***

***filter对每一项都运行传入的函数，函数返回true的项会组成数组并返回***

***map对数组每一项都运行传入的函数，函数返回的结果构成新的数组***

#### ***去重的几种方法***

1. ***利用set去重，let new = new set(重复数组)***

2. ***利用indexOf***

3. ***双重for循环***

   











































### 简述async和await

async用于声明一个function是异步的，await用于等待一个异步方法执行完毕

async返回的是一个promise对象



### 讲解深拷贝和浅拷贝

## Vue

### vuex、localStorage、sessionStorage之间的区别

1. ***vuex存储在内存中,localstorage以文件形式存储在本地,sessionstorage针对一个session进行数据存储.***
2. ***页面刷新后vuex存储的数据会被清除,localstorage是永久存储,sessionstorage临时存储,窗口关闭后数据会被清除***
3. ***vuex用于组件之间的传值,localstorage和sessionstorage则主要用于不同页面之间的传值(其他页面更新数据后,当前页面要刷新才能相应更新),vuex则是响应式的.***



### 为什么vue组件中的data必须是函数?

***Vue根实例的data可以是对象也可以使函数,组件是复用的Vue实例,把公共的模块抽离出来,达到复用和直接使用的效果.如果组件中data是一个对象的话,对象是引用类型,会在堆空间中开辟一片区域,使得所有组件会公共是一个data开辟的区域,一个组件修改所有data数据都会改变.所以组件中的data得是一个函数,利用return返回一个对象,每次使用组件就会返回一个全新的data.组件与组件之间的data互相不干涉,类似于style的scoped***









## HTTP

### POST和GET区别

***相同的是都是HTTP请求***
***区别:***
***get请求在浏览器刷新或者会退的时候是无害的.但是POST请求会重新提交***
***GET数据类型urlencode,POSTshi URLENCODE,form-data***
***get将data和headers一起发给后端,但是post会先发header等到后端返回100以后,再在body中发data给后端***



### 

