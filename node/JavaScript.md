### ES6变量

var全局定义 有变量提升
let块级作用域,必须先定义再使用,不能有变量重名
const就是不能改变的let

### new关键字

- 创建一个空的对象
- 空对象的原型指向于构造函数的原型
- 将空对象作为构造函数的上下文(改变this指向)
- 对构造函数有返回值的处理判断

### 手写new函数

```javascript
function fun(age,name){
    this.age = age
    this.name = name
}
function create(fn,...args) {
    //1,创建一个空的对象
    let obj = {}
    //2,空对象的原型指向于构造函数的原型
    Object.setPrototypeOf(obj,fn.prototype)
    //3,将空对象作为构造函数的上下文(改变this指向)
    let result = fn.apply(obj,args)
    //4,对构造函数有返回值的处理判断
    return result instanceof Object ? result : obj
}

console.log(create(fun,18,'Max'))
console.log(new fun(18,'Max'))
```

### this指向

在ES6之前,谁调用this,this就指向谁
全局就指向windows
在对象中的函数调用就指向对象
事件绑定的this指向调用的节点(和e.target的区别,this指向的是绑定事件的节点,举个例子,在点击事件中点击div中的span的话,this返回的是div节点,e.target返回的是span节点)

### Promise

#### Promise的介绍和基本使用

JS中进行一步编程的新解决方案 旧解决方案是回调函数
promise支持链式调用,解决回调地狱
指定回调函数的方式更加灵活 promise 启动异步任务=>返回promise对象=>给promise对象板顶回调函数(甚至可以在异步任务结束后指定多个)

```javascript
let a = new Promise(function(resolve,reject){

        reject()
    })
    //pending执行中
    //fulfilled
    //renject
    //a是promise对象
    a.then(function(){
        //兑现承诺,这个函数被执行

    }).catch(function(){
        //拒绝承诺,这个函数就会被执行
       
    })
```

#### Promise的介绍和基本使用

JS中进行一步编程的新解决方案 旧解决方案是回调函数
promise支持链式调用,解决回调地狱
指定回调函数的方式更加灵活 promise 启动异步任务=>返回promise对象=>给promise对象板顶回调函数(甚至可以在异步任务结束后指定多个)

```javascript
let a = new Promise(function(resolve,reject){

        reject()
    })
    //pending执行中
    //fulfilled
    //renject
    //a是promise对象
    a.then(function(){
        //兑现承诺,这个函数被执行

    }).catch(function(){
        //拒绝承诺,这个函数就会被执行
       
    })
```

### async/await

### 如何改变this指向

call obj1.function.call(obj2)
apply obj1.function.apply(obj2)
call和apply的区别
call可以往里传入多个参数,apply只能传入两个参数,第二个参数为数组
bind不会自动执行函数,会形成一个新的函数this指向为改变的的参数

### 箭头函数的this

1.当我们使用箭头函数的时候，箭头函数会默认帮我们绑定外层 this 的值，所以在箭头函数中 this 的值和外层的 this 是一样的。
2.箭头函数中的this引用的就是最近作用域中的this
3.向外层作用域中，一层一层查找this，直到有this的定义
4.有的箭头函数都没有自己的 this。 不适合定义一个 对象的方法。

### 解构赋值

快速从对象和数组中获取成员
let [1,2,3,[4,5,[7.8] = arr
按照站位快速获取里面的值

### 对象

JavaScript最基本的数据类型
JavaScript对象也可以从其他对象继承属性，这个其他对象称为其“原型”

#### 创建对象

字面量创建 let obj = {}
内置构造函数 new Object()
自定义构造函数 new createfunction
Object.create({})创建一个新对象,使用其第一个参数作为新对象的原型

#### 删除对象属性

delete操作符
只删除自有属性,无法删除继承属性
操作成功或没有影响会返回true
无法删除全局对象属性

#### 测试对象属性

in对象是否有包含相应名字的自有属性或继承属性
hasOwnProperty()对象是否有给定名字的属性,不能测试继承的属性
propertyIsEnumerable()

#### 枚举/循环遍历对象属性

for/in
Object.keys(对象)返回对象内自有属性名的数组.不包含不可枚举属性,继承属性或名字是符号的属性
Object.getOwnPropertyNames()与Object.keys()类似
Object.getOwnPropertySymbols()返回名字是符号的自有属性
Reflect.ownKeys()返回所有属性名

#### 扩展对象

Object.assign()接受两个或多个对象作为参数,会修改并返回第一个参数,第一个参数是目标对象,会覆盖目标对象的同名属性

#### 序列化对象

把对象的状态转换为字符串的过程
JSON.stringify()序列化
JSON.parse()恢复JS对象

#### 对象方法(原型上的方法)

toString()
toLocalString()
valueOf()
toJSON()

#### 属性获取和设置

getter和setter

### 数组

#### 创建数组

数组字面量 数组中的值不需要常量,可以使任意表达式
扩展操作符
Array()构造函数 传入一个数组参数指定长度,传入两个或更多个数组元素

Array.of()解决Array()没法构造只有一个数值的数组
Array.from()传入可迭代对象或类数组对象作为参数

#### 读写数据元素

#### 稀疏数组

#### 添加和删除数组元素

push unshift
pop shift
delete删除元素不改变length

#### 迭代数组

for/of+extries()

#### 数组方法

#### 数组迭代器方法

forEach()迭代循环数组的每一个元素调用我们后面写入的函数,这个方法可以接受三个参数,第一个是数组元素的值,第二个是数组元素的索引,第三个是数组本身.如果只传入一个参数,那就是数组元素的值

map()迭代循环数组的每一个元素调用我们传入的函数,返回函数的每一个返回值形成一个新的数组,如果数组是稀疏数组,空缺部分不会调用函数,形成的新数组同样是稀疏数组

filter()迭代循环数组的每一个元素调用我们传入的断言函数,函数返回布尔值,返回为true的元素形成一个新的数组

find()和findIndex()迭代循环数组的每一个元素调用我们传入的断言函数,返回第一个经过函数返回true的元素随后停止遍历,find返回元素的值,findIndex返回元素的索引

every()与some()迭代循环数组的每一个元素调用断言函数,调用every的数组如果有一个元素通过断言函数返回false就停止迭代并返回false,全部通过函数后返回true.调用some数组,如果有一个元素调用函数返回true后停止迭代并返回true,只有全部函数返回false才返回false

reduce()与reduceRight()传入两个参数,第一个是执行的函数第一个执行的函数是归并函数需要两个参数,返回的值作为下一次迭代的第一个值.第二个是可选值,作为执行用函数的初始值,第三可传入参数为索引,第四个可选参数是数组本身
reduceRight从最高索引开始调用

flat()和flatMap()将嵌套数组打平,faltMap与Map类似,将map返回的嵌套数组打平

concat()返回一个新数组,包含调用方法的数组元素和传入的参数,如果传入的是数组则只会拼接数组中的元素

#### 栈和队列操作

```javascript
let a = [1,2,3,4,5]
//push()
a.push(6) // 返回[1,2,3,4,5,6] 

//pop()
a.pop() // 返回5 pop返回弹出的那个元素

//shift()
a.shift() // 返回1 shift返回弹出的那个元素

//unshift
a.unshift(6) // [6,1,2,3,4,5]

// slice()
a.slice(0,3) // 从a数组中切除第0-3个数组(不包括3)  [1,2,3]
//如果没有第二个参数则从第一个参数的索引一直切到最后
//参数如果是负数,例-1 = 倒数第一个参数 -2 = 倒数第二个参数


//splice //返回的是被删除元素的数组
a.splice(1,3) // [2,3,4] a = [1,5]
// 第一个参数是删除的起始位置,第二个元素为删除的个数,后面的参数可选,插入到删除位置形成新数组

// fill
a.fill(10,2) // [1,2,10,10,10]
// 第一个参数是填充的元素,第二个参数是开始填充的索引位置(包括其本身),第三个参数是结束填充的索引位置(不包括)

//copyWithin
a.fill(1,2,3) // [1,3,3,4,5]
//第一个参数为复制目的地的索引,第二个参数为需要复制起始值的索引(默认为0),第三个参数为复制终点的索引(默认为数组的长度)
```



#### 数组的排序和索引

```javascript
let a = [1,2,3,4,5]
// indexOf lastIndexOf
a.indexOf(3) // 2 
//从数组中找到和参数相等的元素,并返回其索引,lastIndexOf()从后往前找,如果没有找到都返回-1

// includes
a.includes(1) //true
a.includes(19) //false
//从数组中寻找参数,存在就返回true,没有就返回false.与indexOf的区别在于include可以检测数组中的NaN值

// Sort
a.sort() //默认按照首字母顺序比较进行排序,如果需要对非字母进行排序,要传入一个比较函数.如果是从小到大排序,传入的函数返回值为<0,从大到小,传入返回值>0

// reverse 翻转数组的顺序
```



#### 数组转换字符串

```javascript
//join 将所有数组元素转换为一个字符串,可以传入一个符号参数,作为字符串之间的拼接符
a.join("-") // '1-2-3-4-5'
// 如果不传入参数,默认分隔符为,

//toString()等同于无参数的join
```



#### 静态数组函数

```javascript
Array.isArray([]) //判定参数是否为数组
```





### 第八章函数

本章介绍JavaScript函数.函数是JavaScript程序的一个基本的组成部分,也是几乎所有编程语言共有的特性.其他语言中所说的子例程或过程就是函数

函数是一个JavaScript代码块,定义之后,可以被执行或调用任意多次.JavaScript函数时参数化的,即函数定义可以包含一组标识符,成为参数或形参.这些形参类似函数体内定义的局部变量.函数调用会为这些形参提供值或实参.函数通常会使用实参的值计算自己的返回值,这个返回值会成为函数调用表达式的值.除了实参,每个调用还有另外一个值,即调用上下文,也就是this关键字的值.

如果把函数赋值给一个对象的属性,则可以称其为改对象的方法.如果函数是在一个对象上被调用或通过一个对象被调用,这个对象就是函数的调用上下文或this值.设计用来初始化一个新对象的函数成为构造函数.

JavaScript中的函数是对象,可以通过程序来操控.比如,JavaScript可以把函数赋值给变量,然后再传递给其他函数.因为函数时对象,所以可以在函数上设置属性,甚至调用函数的方法.

JavaScript函数可以嵌套定义在其他函数里,内嵌的函数可以访问函数作用域的任何变量.这意味着JavaScript函数是闭包,基于闭包可以实现重要且强大的编程技巧.

#### 8.1定义函数

在JavaScript中定义函数最直观的方式就是使用function关键字,这个关键字可以用作声明或表达式.ES6定义了一种新的方式,可以不通过function关键字定义函数,即箭头函数.箭头函数的语法特别简介,很适合把函数作为参数传给另一个函数.接下来将分别介绍函数声明,函数表达式和箭头函数这3中定义函数的方式。涉及函数形参的一些函数定义语法的细节

在对象字面量和类定义中，有一个定义方法的快捷语法。等价于使用函数定义表达式并使用基本的name:value对象字面量语法，将其赋值给对象的属性。另一种特殊情况实在对象字面量中使用关键字get和set定义特殊的获取和设置方法。

注意，也可以使用function()构造函数定义新函数。

##### 8.1.1 函数声明

函数声明由function关键字后跟如下组件构成。

- 命名函数的标识符。这个作为函数名的标识符对于函数声明是必须的，它作为一个变量名使用，新定义的函数对象会赋值给这个变量。
- 一对圆括号，中间包含逗号分隔的零或多个标识符。这些标识符是函数参数名，它们就像是函数体内的局部变量。
- 一对花括号，中间包含都好分隔的零或多个标识符。这些标识符是函数的参数名，他们就像是函数体内的局部变量

要理解函数声明，关键是理解函数的名字变成一个变量，这个变量的值就是函数本身。

函数声明语句会被“提升”到包含脚本、函数或代码块的顶部，因此调用以这种方式定义的函数时，调用代码可以出现在函数定义代码之前。对此，另一种表述方式是：在于给JavaScript代码块中声明的所有函数在该块的任何地方都有定义，而且他们会在JavaScript解释器开始执行该块中的任何代码之前被定义.

前面看到的distance()和factorial()函数用来执行计算并得到一个值，他们都使用return将该值返回给调用者。return语句导致函数停止执行并将其表达式的值返回给调用者。如果return语句没有关联的表达式，则函数的返回值是undefined。

printprops()函数不一样；它的任务是输出对象的属性的名字和值。此时并不需要返回值，而且函数也不包含return语句。对printprops()函数调用的值始终的undefined。如果函数并不包含return语句，那么就简单地执行函数体内的每个语句，直到最后向调用者返回undefined。

在ES6之前，函数声明只能出现在JavaScript文件或其他函数的顶部。虽然有些实现弱化了这个限制，但严格来讲在循环体、条件或其他语句块中定义函数都不合法。不过在ES6的严格模式下，函数声明可以出现在语句块中。不过，在语句块中定义的函数只在该块中有定义，对快的外部不可见。

##### 8.1.2函数表达式

函数表达式看起来很像函数声明，但它们出现在复杂表达式或语句的上下文中，而且函数名是可选的。以下是几个函数表达式的实例：

```javascript
// 这个函数表达式定义一个对参数求平方的函数
// 注意，我们把它赋值给一个变量
const square = function(x){return x*x }

// 函数表达式可以包含名字，这对递归有用
const f = function fact(x) { if(x<=1) return 1 ;else return x*fact(x-1)}

// 函数表达式也可以用作其他函数的参数
[3,2,1].sort(function(a,b){return a-b})

// 函数表达式也可以定义完立即调用
let tensquared = (function(x) {return x*x }(10))
```

注意，函数名对定义为表达式的函数而言是可选的，前面看到的多数函数表达式都没有名字。函数声明实际上会声明一个变量，然后把函数对象赋值给它。而函数表达式不会声明变量，至于要把新定义的函数复制给一个常量还是变量都取决于你，这样方便以后多次引用。最佳实践是使用const把函数表达式赋值给常量，以防止意外又给它赋予新值而重写函数。

如果需要引用自身，也可以带函数名，比如前面的阶乘函数。如果函数表达式包含名字，则该函数的局部作用域也会包含一个该名字与函数对象的绑定。实际上，函数名就变成了函数体内的一个局部变量。多数定义为表达式的函数都不需要名字，这让定义更简洁。

使用函数声明定义函数f()与创建一个函数表达式再将其赋值给变量f有一个重要的区别。在使用声明形式时，先创建好函数对象，然后再运行包含它们的代码，而且函数的定义会被提升到顶部，因此在定义函数的语句之前就可以调用它们。但对于定义为表达式的函数就不一样了，这些函数在定义它们的表达式实际被求值以前是不存在的。不仅如此，要调用函数要求必须引用函数，在把函数表达式赋值给变量之前是无法引用函数的，因此定义为表达式的函数不能在它们的定义之前调用。

##### 8.1.3箭头函数

箭头函数是表达式而不是语句，因此不必使用function()关键字，而且也不需要函数名。箭头函数的一般形式是圆括号中都逗号分隔的参数列表，后跟=>，再跟包含在花括号中的函数体

如果函数体只有一个return语句，可以省略return关键字、语句末尾的分号以及花括号，将函数体写成一个表达式，它的值将被返回：

更进一步，如果箭头函数只有一个参数，也可以省略包围参数列表的圆括号

注意点：对于没有参数的箭头函数则必须把空圆括号写出来

另外，如果箭头函数的函数体是一个return语句，但要返回的表达式是对象字面量，那必须把这个对象字面量放在一对圆括号中，以避免解释器分不清花括号到底是函数体的花括号，还是对象字面量的花括号

相比其他方式定义的函数，箭头函数有一个及其重要的区别：它们从定义自己的环境继承this关键字的值，而不是像以其他方式定义的函数那样定义自己的调用上下文。这是箭头函数的一个重要且非常有用的特性。还有一个区别，箭头函数没有prototype属性，这意味着箭头函数不饿能作为新类的构造函数。

##### 8.1.5嵌套函数

在JavaScript中，函数可以嵌套其他函数中。

关于嵌套函数，最重要的是理解它们的变量作用域规则：它们可以访问包含自己外层的函数的参数和变量

#### 8.2调用函数

JavaScript函数通过五种方式来调用

- 作为函数
- 作为方法
- 作为构造函数
- 通过call或apply间接调用
- 通过JavaScript语言特性隐式调用

##### 8.2.1函数调用

在一次调用中，每个实参表达式都会被求值，求值结果会变成函数的实参。换句话说，这些值会被赋予函数定义中的命名形参。换句话说，这些值会被赋予函数定义中的命名形参。在函数体内，对形参的引用会求值为对应的实参值。

对常规函数调用来说，函数的返回值会变成调用表达式的值。如果函数由于解释器到达末尾而返回，则返回值的undefined。如果函数由于解释器执行到return语句而返回，则返回值是return后面表达式的值；如果return语句没有值就是undefined。

###### 条件式调用

在ES2020中，可以在函数表达式后面、左圆括号前面插入?.，从而旨在函数不是null或undefined时调用函数、换句话说，表达式f?.(x)等价于(f !== null && f !== undefined) ? f(x) : undefined

对于非严格模式下的函数调用，调用上下文(this)是全局对象。但在严格模式下，调用上下文是undefined。要注意的是，使用箭头语法定义的函数又有不用：它们总是继承自身定义所在环境的this值。

要作为函数（而非方法）来调用的函数通常不会定义中使用this关键字。但是可以在这些函数中使用this关键字来确定是不是处于严格模式

###### 递归函数与调用栈

##### 8.2.2方法调用

方法其实就是JavaScript的函数，只不过它保存为对象的属性而已。如果有一个函数f和一个对象o，那么可以像这样给o定义一个名为m的方法：o.m = f

对象o有了方法m()后，就可以这样调用 o.m()

如果m()期待两个参数，可以这样调用 o.m(x,y)

方法调用和函数调用有一个重要的区别：调用上下文。属性访问表达式由两部分构成：对象和属性名。在像这样的方法调用表达式中，对象o会成为调用上下文，而函数体可以通过关键字this引用这个对象。

```JavaScript
let calculator = { // 对象字面量
    operand1 : 1,
    operand2 : 2,
    add() {      // 对这个函数使用了方法简写语法
        //注意这里使用了this关键字引用了包含对象
        this.result = this.operand1 + this.operand2
    }
}
calculator.add() //方法调用 计算1+1 = 2


```

//多数方法调用使用点号进行属性访问，但使用方括号的属性访问表达式也可以实现方法调用。比如
o["m"](x,y)
a[0](z)

方法和this关键字是面向对象编程范式的核心。任何用作方法的函数实际上都会隐式收到一个参数，即调用它的对象。通常，方法会在对象上执行某些操作，而方法调用语法是表达函数操作对象这一事实的直观方式























#### 类数组对象

### 原型

通过对象字面量创建的所有对象都有相同的原型对象
使用new关键字和构造函数调用创建的对象，使用构造函数prototype属性的值作为它们的原型

***对象.\*proto\*===构造函数的原型***

#### 原型链

自定义构造函数创建的对象有_proto_这个隐性原型,连接着构造函数的显式原型protptype,构造函数的protptype上有个_proto_链接到Object的prototype,这三者的链接形成了原型链

原型链的定点是Object.prototype = null

#### 面向对象继承

构造函数继承属性,通过改变this指向

原型继承:新对象.prototype = new 想继承的构造函数